<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · OWENS.jl</title><meta name="title" content="API Reference · OWENS.jl"/><meta property="og:title" content="API Reference · OWENS.jl"/><meta property="twitter:title" content="API Reference · OWENS.jl"/><meta name="description" content="Documentation for OWENS.jl."/><meta property="og:description" content="Documentation for OWENS.jl."/><meta property="twitter:description" content="Documentation for OWENS.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OWENS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../setup/">Installation</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/A_simplyRunningOWENS/">Simply Running OWENS</a></li><li><a class="tocitem" href="../../examples/B_detailedInputs/">Detailed Inputs</a></li><li><a class="tocitem" href="../../examples/C_customizablePreprocessing/">Customizable Preprocessing</a></li></ul></li><li><a class="tocitem" href="../../OWENS_Dev_Guide/">Developer Guide</a></li><li><a class="tocitem" href="../../FramesOfReference/">Frames of Reference</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Types-and-functions"><span>Types and functions</span></a></li></ul></li><li><a class="tocitem" href="../../legacyUserGuide/">Legacy User Guide</a></li><li><a class="tocitem" href="../../VAWTGenUserGuide/">Legacy VAWTGen Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#OWENS.Bin"><code>OWENS.Bin</code></a></li><li><a href="#OWENS.Blade"><code>OWENS.Blade</code></a></li><li><a href="#OWENS.BladeData"><code>OWENS.BladeData</code></a></li><li><a href="#OWENS.CactusGeom"><code>OWENS.CactusGeom</code></a></li><li><a href="#OWENS.DriveShaftProps"><code>OWENS.DriveShaftProps</code></a></li><li><a href="#OWENS.Inputs-Tuple{}"><code>OWENS.Inputs</code></a></li><li><a href="#OWENS.Iteration_Parameters"><code>OWENS.Iteration_Parameters</code></a></li><li><a href="#OWENS.NuMad"><code>OWENS.NuMad</code></a></li><li><a href="#OWENS.Strut"><code>OWENS.Strut</code></a></li><li><a href="#OWENS.plyproperties-Tuple{}"><code>OWENS.plyproperties</code></a></li><li><a href="#OWENS.Unsteady-Tuple{Any}"><code>OWENS.Unsteady</code></a></li><li><a href="#OWENS.Unsteady_Land-Tuple{Any}"><code>OWENS.Unsteady_Land</code></a></li><li><a href="#OWENS.calcHydroResidual-NTuple{5, Any}"><code>OWENS.calcHydroResidual</code></a></li><li><a href="#OWENS.calculateDriveShaftReactionTorque-NTuple{5, Any}"><code>OWENS.calculateDriveShaftReactionTorque</code></a></li><li><a href="#OWENS.calculateElementOrientation-Tuple{Any}"><code>OWENS.calculateElementOrientation</code></a></li><li><a href="#OWENS.calculatePsiTheta-Tuple{Any}"><code>OWENS.calculatePsiTheta</code></a></li><li><a href="#OWENS.count_cycles-Tuple{Vector{Float64}, Vector{Float64}}"><code>OWENS.count_cycles</code></a></li><li><a href="#OWENS.createGeneralTransformationMatrix-Tuple{Any, Any}"><code>OWENS.createGeneralTransformationMatrix</code></a></li><li><a href="#OWENS.createInitCondArray-Tuple{Any, Any, Any}"><code>OWENS.createInitCondArray</code></a></li><li><a href="#OWENS.createSingleRotationDCM-Tuple{Any, Any}"><code>OWENS.createSingleRotationDCM</code></a></li><li><a href="#OWENS.create_arcus_mesh-Tuple{}"><code>OWENS.create_arcus_mesh</code></a></li><li><a href="#OWENS.create_hawt_biwing_mesh-Tuple{}"><code>OWENS.create_hawt_biwing_mesh</code></a></li><li><a href="#OWENS.create_hawt_mesh-Tuple{}"><code>OWENS.create_hawt_mesh</code></a></li><li><a href="#OWENS.create_mesh_struts-Tuple{}"><code>OWENS.create_mesh_struts</code></a></li><li><a href="#OWENS.externalForcing-NTuple{4, Any}"><code>OWENS.externalForcing</code></a></li><li><a href="#OWENS.extrap_pred_vals-NTuple{4, Any}"><code>OWENS.extrap_pred_vals</code></a></li><li><a href="#OWENS.find_boundary_vals-Tuple{Vector{OWENS.Cycle}}"><code>OWENS.find_boundary_vals</code></a></li><li><a href="#OWENS.find_range-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real"><code>OWENS.find_range</code></a></li><li><a href="#OWENS.frame_convert-Tuple{Any, Any}"><code>OWENS.frame_convert</code></a></li><li><a href="#OWENS.generateOutputFilename-Tuple{Any, Any}"><code>OWENS.generateOutputFilename</code></a></li><li><a href="#OWENS.getGustVel-NTuple{6, Any}"><code>OWENS.getGustVel</code></a></li><li><a href="#OWENS.getOWENSPreCompOutput-Tuple{Any}"><code>OWENS.getOWENSPreCompOutput</code></a></li><li><a href="#OWENS.getRotorPosSpeedAccelAtTime-NTuple{4, Any}"><code>OWENS.getRotorPosSpeedAccelAtTime</code></a></li><li><a href="#OWENS.getSectPropsFromOWENSPreComp-Tuple{Any, Any, Any}"><code>OWENS.getSectPropsFromOWENSPreComp</code></a></li><li><a href="#OWENS.mapACDMS-NTuple{5, Any}"><code>OWENS.mapACDMS</code></a></li><li><a href="#OWENS.mapAD15-NTuple{4, Any}"><code>OWENS.mapAD15</code></a></li><li><a href="#OWENS.mapCactusLoadsFile-NTuple{6, Any}"><code>OWENS.mapCactusLoadsFile</code></a></li><li><a href="#OWENS.my_getABD!"><code>OWENS.my_getABD!</code></a></li><li><a href="#OWENS.my_getplystrain"><code>OWENS.my_getplystrain</code></a></li><li><a href="#OWENS.my_getz"><code>OWENS.my_getz</code></a></li><li><a href="#OWENS.mywrite_vtk-NTuple{5, Any}"><code>OWENS.mywrite_vtk</code></a></li><li><a href="#OWENS.mywrite_vtk-Tuple{Any, Any}"><code>OWENS.mywrite_vtk</code></a></li><li><a href="#OWENS.omegaSpecCheck-NTuple{4, Any}"><code>OWENS.omegaSpecCheck</code></a></li><li><a href="#OWENS.owens-Tuple{Any, Any}"><code>OWENS.owens</code></a></li><li><a href="#OWENS.plotMesh-NTuple{7, Any}"><code>OWENS.plotMesh</code></a></li><li><a href="#OWENS.rainflow-Tuple{Any}"><code>OWENS.rainflow</code></a></li><li><a href="#OWENS.readBCdata-Tuple{Any, Any, Any}"><code>OWENS.readBCdata</code></a></li><li><a href="#OWENS.readBladeData-Tuple{Any}"><code>OWENS.readBladeData</code></a></li><li><a href="#OWENS.readCactusGeom-Tuple{Any}"><code>OWENS.readCactusGeom</code></a></li><li><a href="#OWENS.readElementData-NTuple{4, Any}"><code>OWENS.readElementData</code></a></li><li><a href="#OWENS.readGeneratorProps-Tuple{Any}"><code>OWENS.readGeneratorProps</code></a></li><li><a href="#OWENS.readMesh-Tuple{Any}"><code>OWENS.readMesh</code></a></li><li><a href="#OWENS.readNuMadGeomCSV-Tuple{Any}"><code>OWENS.readNuMadGeomCSV</code></a></li><li><a href="#OWENS.readNuMadMaterialsCSV-Tuple{Any}"><code>OWENS.readNuMadMaterialsCSV</code></a></li><li><a href="#OWENS.readResultsModalOut-Tuple{Any, Any}"><code>OWENS.readResultsModalOut</code></a></li><li><a href="#OWENS.rigidBodyRotation-NTuple{5, Any}"><code>OWENS.rigidBodyRotation</code></a></li><li><a href="#OWENS.run34m-NTuple{6, Any}"><code>OWENS.run34m</code></a></li><li><a href="#OWENS.runDLC-Tuple{Any, Any, Any}"><code>OWENS.runDLC</code></a></li><li><a href="#OWENS.simpleGenerator-Tuple{Any, Any}"><code>OWENS.simpleGenerator</code></a></li><li><a href="#OWENS.sort_peaks"><code>OWENS.sort_peaks</code></a></li><li><a href="#OWENS.sum_cycles-Union{Tuple{T}, Tuple{Vector{OWENS.Cycle}, Union{StepRangeLen{T}, Vector{T}}, Union{StepRangeLen{T}, Vector{T}}}} where T&lt;:Real"><code>OWENS.sum_cycles</code></a></li><li><a href="#OWENS.timeIntegrateSubSystem-NTuple{8, Any}"><code>OWENS.timeIntegrateSubSystem</code></a></li><li><a href="#OWENS.transMat-Tuple{Any, Any, Any}"><code>OWENS.transMat</code></a></li><li><a href="#OWENS.trapezoidalRule-NTuple{4, Any}"><code>OWENS.trapezoidalRule</code></a></li><li><a href="#OWENS.updateRotorRotation-NTuple{9, Any}"><code>OWENS.updateRotorRotation</code></a></li><li><a href="#OWENS.userDefinedRotorSpeedProfile-Tuple{Any}"><code>OWENS.userDefinedRotorSpeedProfile</code></a></li><li><a href="#OWENS.viz-Tuple{Any}"><code>OWENS.viz</code></a></li><li><a href="#OWENS.writeOwensNDL-NTuple{4, Any}"><code>OWENS.writeOwensNDL</code></a></li></ul><h2 id="Types-and-functions"><a class="docs-heading-anchor" href="#Types-and-functions">Types and functions</a><a id="Types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.Bin" href="#OWENS.Bin"><code>OWENS.Bin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Inputs pointing to the file paths of compiled binaries of external libraries</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.Blade" href="#OWENS.Blade"><code>OWENS.Blade</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal, struct containing the CACTUS geometry file data for a blade</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.BladeData" href="#OWENS.BladeData"><code>OWENS.BladeData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal, struct containing blade specific data and location within the mesh</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.CactusGeom" href="#OWENS.CactusGeom"><code>OWENS.CactusGeom</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal, struct containing the CACTUS geometry file data</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.DriveShaftProps" href="#OWENS.DriveShaftProps"><code>OWENS.DriveShaftProps</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal, driveshaft stiffness k and damping c</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.Inputs-Tuple{}" href="#OWENS.Inputs-Tuple{}"><code>OWENS.Inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Inputs(;analysisType = &quot;TNB&quot;,     turbineStartup = 0,     usingRotorSpeedFunction = false,     tocp = [0.0,1.1],     tocp<em>Vinf = [0.0,1.1],     numTS = 50.0,     delta</em>t = 2e-3,     Omegaocp = [7.2,7.2] ./ 60,     Vinfocp = [12.0,12.0],     aeroLoadsOn = 1,     AD15On = false,     driveTrainOn = false,     generatorOn = false,     hydroOn = false,     topsideOn = true,     interpOrder = 2,     hd<em>input</em>file = &quot;none&quot;,     md<em>input</em>file = &quot;none&quot;,     JgearBox = 0.0,     gearRatio = 1.0,     gearBoxEfficiency = 1.0,     useGeneratorFunction = false,     generatorProps = 0.0,     ratedTorque = 0.0,     zeroTorqueGenSpeed = 0.0,     pulloutRatio = 0.0,     ratedGenSlipPerc = 0.0,     OmegaGenStart = 0.0,     omegaControl = false,     OmegaInit = 7.2/60, #TODO: simplify this in the code since it is redundant     rigid = false, #turn off structural dynamics     aeroloadfile = &quot;module<em>path/../test/data/input</em>files<em>test/DVAWT</em>2B<em>LCDT</em>ElementData.csv&quot;,     owensfile = &quot;module<em>path/../test/data/input</em>files<em>test/</em>15mTower<em>transient</em>dvawt<em>c</em>2_lcdt.owens&quot;,     outFilename = &quot;none&quot;,     numDofPerNode = 6,     bladeData = [],     driveShaftProps = DriveShaftProps(0.0,0.0)     TOl = 1e-4,     MAXITER = 300,     iterwarnings = true,     )</p><p>Model inputs for OWENS coupled analysis, struct</p><p><strong>Inputs</strong></p><ul><li><code>analysisType::string</code>: Newmark Beta time stepping &quot;TNB&quot;, Dean time stepping &quot;TD&quot;, modal &quot;M&quot;</li><li><code>turbineStartup::int</code>: 1 forced start-up using generator as motor, 2 self-starting mode, 0 specified rotor speed mode&quot;)</li><li><code>usingRotorSpeedFunction::bool</code>: use user specified rotor speed profile function</li><li><code>tocp::Array{&lt;:float}</code>: = time points for rotor speed profile (s)</li><li><code>tocp_Vinf::Array{&lt;:float}</code>: = time points for specified Vinf profile (s)</li><li><code>numTS::int</code>: total number of timesteps to run</li><li><code>delta_t::float</code>: timestep interval (s)</li><li><code>Omegaocp::Array{&lt;:float}</code>: = rotor speed points for rotor speed profile (Hz)</li><li><code>Vinfocp::Array{&lt;:float}</code>: = rotor speed points for specified Vinf profile (Hz)</li><li><code>aeroLoadsOn::bool</code>: #0 off, 1 one way, 1.5 one way with deformation from last timestep, 2 two way</li><li><code>AD15On::bool</code>: flag to use AD15 for aero</li><li><code>driveTrainOn::bool</code>: flag to include drivetrain effects</li><li><code>generatorOn::bool</code>: flag to include generator effects</li><li><code>hydroOn::bool</code>: flag to include platform coupling</li><li><code>interpOrder::int</code>: order used for extrapolating inputs and states, 0 flat, 1 linear, 2 quadratic</li><li><code>hd_input_file::string</code>: file path to the HydroDyn .dat input file</li><li><code>md_input_file::string</code>: file path to the MoorDyn .dat input file</li><li><code>JgearBox::float</code>: gearbox intertia, standard SI units</li><li><code>gearRatio::float</code>: gearbox gear ratio</li><li><code>gearBoxEfficiency::float</code>: gearbox efficiency (typically 0-1)</li><li><code>useGeneratorFunction::bool</code>: = flag to use user specified generator profile</li><li><code>generatorProps::float</code>: not used, should clean up</li><li><code>ratedTorque::float</code>: Generator rated max torque</li><li><code>zeroTorqueGenSpeed::float</code>: rated generator speed (minus slippage)</li><li><code>pulloutRatio::float</code>: Fraction of the min/max torque that the generator engages/disengages</li><li><code>ratedGenSlipPerc::float</code>: extra speed from slipping?</li><li><code>OmegaGenStart::float</code>: speed (Hz) at which generator would kick in</li><li><code>omegaControl::bool</code>: false for fixed speed, true for dynamic</li><li><code>OmegaInit::float</code>: initial rotor speed (Hz)</li><li><code>aeroloadfile::string</code>: string of the name and path for the cactus aeroloads if using the old serial owens call</li><li><code>owensfile::string</code>: string of the name and path for the owens input file if using the old serial owens call</li><li><code>potflowfile::string</code>: string of the prefix and path for the directory containing the potential flow files from WAMIT (required by HydroDyn)</li><li><code>outFilename::string</code>: path and name of output file, will be overwritten if already exists</li><li><code>numDofPerNode::int</code>: number of degrees of freedom per node</li><li><code>bladeData::BladeData</code>: see ?BladeData, only used if calling the old serial owens function</li><li><code>driveShaftProps::DriveShaftProps</code>: see ?DriveShaftProps</li><li><code>TOl::float</code>: gauss-seidel iteration tolerance</li><li><code>MAXITER::int</code>: gauss-seidel maximum iterations</li><li><code>iterwarnings::bool</code>: iteration warnings flag</li></ul><p><strong>Outputs:</strong></p><ul><li><code>OWENS.Inputs</code>:</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.Iteration_Parameters" href="#OWENS.Iteration_Parameters"><code>OWENS.Iteration_Parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal, gauss-seidel iteration parameters </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.NuMad" href="#OWENS.NuMad"><code>OWENS.NuMad</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NuMad(n<em>web,n</em>stack,n<em>segments,span,airfoil,te</em>type,twist<em>d,chord,xoffset,aerocenter,stack</em>mat<em>types,stack</em>layers,segments,DPtypes,skin,web<em>stack,web</em>dp)</p><p>Parameters defining the blade composite layup. See NuMad user guide SAND2012_7028 appendix B for more details</p><p><strong>Arguments</strong></p><ul><li><code>n_web::Int64</code>: number of shear webs</li><li><code>n_stack::Int64</code>: number of predefined composite stacks</li><li><code>n_segments::Int64</code>: number of segments around the airfoil</li><li><code>span::Vector{Float64}</code>: span-wise position</li><li><code>airfoil::Vector{String}</code>: airfoil name</li><li><code>te_type::Vector{String}</code>: trailing edge type</li><li><code>twist_d::Vector{Float64}</code>: twist_d in degrees</li><li><code>chord::Vector{Float64}</code>: chord length</li><li><code>xoffset::Vector{Float64}</code>: The distance from the “nose” of a station to the blade reference axis.</li><li><code>aerocenter::Vector{Float64}</code>: This is an aerodynamic parameter that is an output from aerodynamic performance analysis of a two-dimensional airfoil section. The aerodynamic center is the point along the chord where the aerodynamic pitching moment does not vary with changes in angle of attack.</li><li><code>stack_mat_types::Vector{Int64}</code>: Material numbers used that correspond to each stack number</li><li><code>stack_layers::Array{Int64,2}</code>: number of layers at each span used corresponding to each material type (first index corresponds to spanwise position, second index corresponds to the stack number)</li><li><code>segments::Array{Float64,2}</code>: normalized starting and stopping points of each section (i.e. leading edge, sparcap, etc).  First index corresponds to  spanwise position, second index corresponds to the section, except there is an extra first column starting at -1 for the trailing edge. There must be a leading edge position at 0, and the last column must be 1 corresponding to the trailing edge again.  Positions are fractions of the chord, lower (HP) is negative, upper (LP) is positive</li><li><code>DPtypes::Array{Int64,2}</code>: division point types (NOTE THAT THIS ISN&#39;T IMPLEMENTED AND DOES NOTHING CURRENTLY, i.e. only SINGLE is being used). First index corresponds to  spanwise positoin, second corresponds to section number</li><li><code>skin_seq::Array{Seq,2}</code>: stack sequence, is an array of structures, each containing a Vector{Int64} of the sequence (i.e. skin[2,5].seq). First index corresponds to spanwise positoin, second index the section</li><li><code>web_seq::Array{Seq,2}</code>: same format and meaning as skin sequence, but for the webs with the second index corresponding to the web number</li><li><code>web_dp::Array{Seq,2}</code>: same format as skin sequence, but this corresponds to the section numbers the web connects to at the top and bottom at both edges. There are always four entries in the CSV list and the order goes as follows: inboard LP, inboard HP, outboard HP, outboard LP.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.Strut" href="#OWENS.Strut"><code>OWENS.Strut</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal, struct containing the CACTUS geometry file data for a strut</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.plyproperties-Tuple{}" href="#OWENS.plyproperties-Tuple{}"><code>OWENS.plyproperties</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Struct containing</p><p>material names</p><p>Composites.Material structs for each material name - see ?Composites.Material</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.Unsteady-Tuple{Any}" href="#OWENS.Unsteady-Tuple{Any}"><code>OWENS.Unsteady</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unsteady(model,topModel,mesh,el,aero;getLinearizedMatrices=false)</p><p>Executable function for transient analysis. Provides the interface of various     external module with transient structural dynamics analysis capability.</p><pre><code class="nohighlight hljs"># Input
* `inputs::Inputs`: see ?Inputs
* `topModel::FEAModel`: see ?OWENSFEA.FEAModel
* `mesh::Mesh`: see ?OWENSFEA.Mesh
* `el::El`: see ?OWENSFEA.El
* `bin::Bin`: see ?Bin
* `aero::function`: Fexternal, Fdof = aero(t) where Fexternal is the force on each affected mesh dof and Fdof is the corresponding DOFs affected
* `getLinearizedMatrices::Bool`: Flag to save the linearized matrices
* `elStorage::ElStorage.ElStorage`: Optional object containing stored element matrices
* `u_s::Array{&lt;:float}`: Optional warm start of top deflections, of length Nnodes x Ndof


# Output
* `t`: time array
* `aziHist`: azimuthal history array
* `OmegaHist`: rotational speed array history
* `OmegaDotHist`: rotational acceleration array history
* `gbHist`: gearbox position history array
* `gbDotHist`: gearbox velocity history array
* `gbDotDotHist`: gearbox acceleration history array
* `FReactionHist`: Nodal reaction 6dof forces history
* `rigidDof`:
* `genTorque`: generator torque history
* `genPower`: generator power history
* `torqueDriveShaft`: driveshaft torque history
* `uHist`: mesh displacement history for each dof
* `epsilon_x_hist`: strain history for eps_xx_0 for each dof
* `epsilon_y_hist`: strain history for eps_xx_z for each dof
* `epsilon_z_hist`: strain history for eps_xx_y for each dof
* `kappa_x_hist`: strain history for gam_xz_0 for each dof
* `kappa_y_hist`: strain history for gam_xz_y for each dof
* `kappa_z_hist`: strain history for gam_xy_0 for each dof</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.Unsteady_Land-Tuple{Any}" href="#OWENS.Unsteady_Land-Tuple{Any}"><code>OWENS.Unsteady_Land</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unsteady(model,topModel,mesh,el,aero;getLinearizedMatrices=false)</p><p>Executable function for transient analysis. Provides the interface of various     external module with transient structural dynamics analysis capability.</p><pre><code class="nohighlight hljs"># Input
* `inputs::Model`: see ?Model
* `topModel::FEAModel`: see ?OWENSFEA.FEAModel
* `mesh::Mesh`: see ?OWENSFEA.Mesh
* `el::El`: see ?OWENSFEA.El
* `bin::Bin`: see ?Bin
* `aero::function`: Fexternal, Fdof = aero(t) where Fexternal is the force on each affected mesh dof and Fdof is the corresponding DOFs affected
* `getLinearizedMatrices::Bool`: Flag to save the linearized matrices
* `elStorage::ElStorage.ElStorage`: Optional object containing stored element matrices
* `u_s::Array{&lt;:float}`: Optional warm start of top deflections, of length Nnodes x Ndof


# Output
* `t`: time array
* `aziHist`: azimuthal history array
* `OmegaHist`: rotational speed array history
* `OmegaDotHist`: rotational acceleration array history
* `gbHist`: gearbox position history array
* `gbDotHist`: gearbox velocity history array
* `gbDotDotHist`: gearbox acceleration history array
* `FReactionHist`: Nodal reaction 6dof forces history
* `rigidDof`:
* `genTorque`: generator torque history
* `genPower`: generator power history
* `torqueDriveShaft`: driveshaft torque history
* `uHist`: mesh displacement history for each dof
* `epsilon_x_hist`: strain history for eps_xx_0 for each dof
* `epsilon_y_hist`: strain history for eps_xx_z for each dof
* `epsilon_z_hist`: strain history for eps_xx_y for each dof
* `kappa_x_hist`: strain history for gam_xz_0 for each dof
* `kappa_y_hist`: strain history for gam_xz_y for each dof
* `kappa_z_hist`: strain history for gam_xy_0 for each dof</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.calcHydroResidual-NTuple{5, Any}" href="#OWENS.calcHydroResidual-NTuple{5, Any}"><code>OWENS.calcHydroResidual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_hydro_residual(new_accels, new_hydro_frcs, md_frc, u, FMultiplier)</code></pre><p>Internal, finds the residual of the platform accelerations/forces when adding in new values from HydroDyn, MoorDyn, and OWENSFEA.</p><p><strong>Input</strong></p><ul><li><code>new_accels::Vector{&lt;:float}</code>: the new platform accelerations in the inertial reference frame from OWENSFEA  (m/s/s)</li><li><code>new_hydro_frcs::Vector{&lt;:float}</code>: the new platform hydro forces in the inertial reference frame from HydroDyn (N)</li><li><code>md_frc::Vector{&lt;:float}</code>: the mooring forces at the platform in the inertial reference frame from MoorDyn (N)</li><li><code>u::Vector{&lt;:float}</code>: input vector containing platform loads and accelerations prior to the new additions</li><li><code>FMultiplier::Number</code>: scaling factor used to make the loads/accelerations in the same magnitude for the Jacobians</li></ul><p><strong>Output</strong></p><ul><li><code>u_resid</code>: vector containing residual between the input u and the new load/accelerations</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.calculateDriveShaftReactionTorque-NTuple{5, Any}" href="#OWENS.calculateDriveShaftReactionTorque-NTuple{5, Any}"><code>OWENS.calculateDriveShaftReactionTorque</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculateDriveShaftReactionTorque(driveShaftProps,thetaRotor,thetaGB,thetaDotRotor,thetaDotGB)</code></pre><p>Internal, calculates reaction torque of driveshaft</p><p>#Input</p><ul><li><code>driveShaftProps</code>:    object containing driveshaft properties</li><li><code>thetaRotor</code>:         azimuth position of rotor/rotor shaft (rad)</li><li><code>thetaGB</code>:            azimuth position of gearbox shaft (rad)</li><li><code>thetaDotRotor</code>:      angular velocity of rotor/rotor shaft (rad/s)</li><li><code>thetaDotGB</code>:         angular velocity of gearbox shaft (rad/s)</li></ul><p>#Output</p><ul><li><code>torque</code>: reaction torque of drive shaft</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.calculateElementOrientation-Tuple{Any}" href="#OWENS.calculateElementOrientation-Tuple{Any}"><code>OWENS.calculateElementOrientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculateElementOrientation(mesh)</code></pre><p>Calculates the orientation of elements in a mesh.</p><p>#Input</p><ul><li><code>mesh::OWENSFEA.Mesh</code>  see ?OWENSFEA.Mesh object containing mesh data</li></ul><p>#Output</p><ul><li><code>elOr::OWENSFEA.Ort</code>  see ?OWENSFEA.Ort object containing element orientation data</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.calculatePsiTheta-Tuple{Any}" href="#OWENS.calculatePsiTheta-Tuple{Any}"><code>OWENS.calculatePsiTheta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculatePsiTheta(v)</code></pre><p>Calculates the orientation of a single element. A local element frame is related to a hub frame through a transformation matrix CHtoE (transforming a vector from an element frame E to a global frame H) such that CHtoE = [M2(Theta)]*[M3(Psi)]. Here [M2( )] is a direction cosine matrix about a 2 axis and [M3( )] is a direction cosine matrix about a 3 axis.</p><p>#Input</p><ul><li><code>v</code>:      vector from node 1 to node 2 of an element</li></ul><p>#Output</p><ul><li><code>Psi</code>:    &quot;3&quot; angle for element orientation (deg)</li><li><code>Theta</code>:  &quot;2&quot; angle for element orientation (deg)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.count_cycles-Tuple{Vector{Float64}, Vector{Float64}}" href="#OWENS.count_cycles-Tuple{Vector{Float64}, Vector{Float64}}"><code>OWENS.count_cycles</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Count the cycles from the data </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.createGeneralTransformationMatrix-Tuple{Any, Any}" href="#OWENS.createGeneralTransformationMatrix-Tuple{Any, Any}"><code>OWENS.createGeneralTransformationMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createGeneralTransformationMatrix(angleArray,axisArray)</code></pre><p>Calculates the transformation matrix assocaited with a general Euler rotation sequence.</p><p>#Input</p><ul><li><code>angleArray</code>:      = array of angles for Euler rotation sequence</li><li><code>axisArray</code>:       = array of axis of rotatoins for Euler rotation</li></ul><p>#Output</p><ul><li><code>dcmTotal</code>:        = transformation matrix of specified euler rotation sequence</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.createInitCondArray-Tuple{Any, Any, Any}" href="#OWENS.createInitCondArray-Tuple{Any, Any, Any}"><code>OWENS.createInitCondArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setInitConditions(initDisps, numNodes, numDOFPerNode)</code></pre><p>Creates the formatted initial conditions array needed by OWENSFEA</p><p>#Input</p><ul><li><code>initDisps</code>: an array of length numDOFPerNode specifying the initial displacement of each DOF</li><li><code>numNodes</code>: the number of nodes in the given mesh</li><li><code>numDOFPerNode</code>: the number of unconstrained degrees of freedom calculated in each node</li></ul><p>#Output</p><ul><li><code>initCond</code>: array containing initial conditions.   initCond(i,1) node number for init cond i.   initCond(i,2) local DOF number for init cond i.   initCond(i,3) value for init cond i.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.createSingleRotationDCM-Tuple{Any, Any}" href="#OWENS.createSingleRotationDCM-Tuple{Any, Any}"><code>OWENS.createSingleRotationDCM</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a direction cosine matrix (dcm) associated with a rotation of angleDeg about axisNum.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.create_arcus_mesh-Tuple{}" href="#OWENS.create_arcus_mesh-Tuple{}"><code>OWENS.create_arcus_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>create<em>arcus</em>mesh(;Ht = 15.0,     Hb = 147.148-15.0, #blade height     R = 54.014, # m bade radius     nblade = 3,     ntelem = 30, #tower elements     nbelem = 30, #blade elements     ncelem = 4,     strut<em>mountpoint = 0.01, # This puts struts at top and bottom     bshapex = zeros(nbelem+1), #Blade shape, magnitude is irrelevant, scaled based on height and radius above     bshapez = zeros(nbelem+1),     joint</em>type = 0,     cables<em>connected</em>to<em>blade</em>base = true,     angularOffset = 0.0)</p><p>ARCUS mesh configuration: no tower between blades, no struts, but cables from top center attaching to specified blade mount point at base</p><p>#Inputs</p><ul><li><code>Ht::float</code>: height of tower before blades attach (m)</li><li><code>Hb::float</code>: blade height (m)</li><li><code>R::float</code>: bade radius (m)</li><li><code>nblade::int</code>: number of blades</li><li><code>ntelem::int</code>: number of tower elements</li><li><code>nbelem::int</code>: number of blade elements</li><li><code>ncelem::int</code>: number of strut elements</li><li><code>c_mount_ratio::float</code>: factor of blade height where the struts attach on both top and bottom</li><li><code>bshapex::Array{&lt;:float}</code>: Blade shape, magnitude is irrelevant, scaled based on height and radius above</li><li><code>bshapez::Array{&lt;:float}</code>: Blade shape, magnitude is irrelevant, scaled based on height and radius above</li><li><code>joint_type::int</code>: 0 is fixed, 1 is about x-axis, 2 is y-axis, etc</li><li><code>cables_connected_to_blade_base::bool</code>: = true,</li><li><code>angularOffset::float</code>: (rad) angular offset of mesh generation, typically used to match CACTUS input.  Value of 0 puts blade 1 at the &quot;north&quot; position and the others populate counterclockwise when looking down</li></ul><p>#Outputs</p><ul><li><code>mymesh::OWENSFEA.Mesh</code>: see ?OWENSFEA.Mesh</li><li><code>ort::OWENSFEA.Ort</code>: see ?OWENSFEA.Ort</li><li><code>myjoint:Array{&lt;:float}</code>: see ?OWENSFEA.FEAModel.joint</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.create_hawt_biwing_mesh-Tuple{}" href="#OWENS.create_hawt_biwing_mesh-Tuple{}"><code>OWENS.create_hawt_biwing_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>create<em>hawt</em>biwing<em>mesh(;Ht = 15.0,     Hb = 147.148-15.0, #blade height     R = 54.014, # m bade radius     nblade = 3,     ntelem = 30, #tower elements     nbelem = 30, #blade elements     ncelem = 4,     strut</em>mountpoint = 0.01, # This puts struts at top and bottom     bshapex = zeros(nbelem+1), #Blade shape, magnitude is irrelevant, scaled based on height and radius above     bshapez = zeros(nbelem+1),     joint<em>type = 0,     cables</em>connected<em>to</em>blade_base = true,     angularOffset = 0.0)</p><p>#Inputs</p><ul><li><code>Ht::float</code>: height of tower before blades attach (m)</li><li><code>Hb::float</code>: blade height (m)</li><li><code>R::float</code>: bade radius (m)</li><li><code>nblade::int</code>: number of blades</li><li><code>ntelem::int</code>: number of tower elements</li><li><code>nbelem::int</code>: number of blade elements</li><li><code>ncelem::int</code>: number of strut elements</li><li><code>c_mount_ratio::float</code>: factor of blade height where the struts attach on both top and bottom</li><li><code>bshapex::Array{&lt;:float}</code>: Blade shape, magnitude is irrelevant, scaled based on height and radius above</li><li><code>bshapez::Array{&lt;:float}</code>: Blade shape, magnitude is irrelevant, scaled based on height and radius above</li><li><code>joint_type::int</code>: 0 is fixed, 1 is about x-axis, 2 is y-axis, etc</li><li><code>cables_connected_to_blade_base::bool</code>: = true,</li><li><code>angularOffset::float</code>: (rad) angular offset of mesh generation, typically used to match CACTUS input.  Value of 0 puts blade 1 at the &quot;north&quot; position and the others populate counterclockwise when looking down</li></ul><p>#Outputs</p><ul><li><code>mymesh::OWENSFEA.Mesh</code>: see ?OWENSFEA.Mesh</li><li><code>ort::OWENSFEA.Ort</code>: see ?OWENSFEA.Ort</li><li><code>myjoint:Array{&lt;:float}</code>: see ?OWENSFEA.FEAModel.joint</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.create_hawt_mesh-Tuple{}" href="#OWENS.create_hawt_mesh-Tuple{}"><code>OWENS.create_hawt_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>create<em>hawt</em>mesh(;Ht = 15.0,     Hb = 147.148-15.0, #blade height     R = 54.014, # m bade radius     nblade = 3,     ntelem = 30, #tower elements     nbelem = 30, #blade elements     ncelem = 4,     strut<em>mountpoint = 0.01, # This puts struts at top and bottom     bshapex = zeros(nbelem+1), #Blade shape, magnitude is irrelevant, scaled based on height and radius above     bshapez = zeros(nbelem+1),     joint</em>type = 0,     cables<em>connected</em>to<em>blade</em>base = true,     angularOffset = 0.0)</p><p>ARCUS mesh configuration: no tower between blades, no struts, but cables from top center attaching to specified blade mount point at base</p><p>#Inputs</p><ul><li><code>Ht::float</code>: height of tower before blades attach (m)</li><li><code>Hb::float</code>: blade height (m)</li><li><code>R::float</code>: bade radius (m)</li><li><code>nblade::int</code>: number of blades</li><li><code>ntelem::int</code>: number of tower elements</li><li><code>nbelem::int</code>: number of blade elements</li><li><code>ncelem::int</code>: number of strut elements</li><li><code>c_mount_ratio::float</code>: factor of blade height where the struts attach on both top and bottom</li><li><code>bshapex::Array{&lt;:float}</code>: Blade shape, magnitude is irrelevant, scaled based on height and radius above</li><li><code>bshapez::Array{&lt;:float}</code>: Blade shape, magnitude is irrelevant, scaled based on height and radius above</li><li><code>joint_type::int</code>: 0 is fixed, 1 is about x-axis, 2 is y-axis, etc</li><li><code>cables_connected_to_blade_base::bool</code>: = true,</li><li><code>angularOffset::float</code>: (rad) angular offset of mesh generation, typically used to match CACTUS input.  Value of 0 puts blade 1 at the &quot;north&quot; position and the others populate counterclockwise when looking down</li></ul><p>#Outputs</p><ul><li><code>mymesh::OWENSFEA.Mesh</code>: see ?OWENSFEA.Mesh</li><li><code>ort::OWENSFEA.Ort</code>: see ?OWENSFEA.Ort</li><li><code>myjoint:Array{&lt;:float}</code>: see ?OWENSFEA.FEAModel.joint</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.create_mesh_struts-Tuple{}" href="#OWENS.create_mesh_struts-Tuple{}"><code>OWENS.create_mesh_struts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>return mymesh, myort, myjoint, AD15bldNdIdxRng, AD15bldElIdxRng = create<em>mesh</em>struts(;Ht = 15.0,     Hb = 147.148-15.0, #blade height     R = 54.014, # m bade radius     AD15hubR = 2.0,     nblade = 3,     ntelem = 30, #tower elements     nbelem = 30, #blade elements     nselem = 4,     strut<em>twr</em>mountpointbot = 0.01, # This puts struts at top and bottom     strut<em>twr</em>mountpointtop = 0.99, # This puts struts at top and bottom     strut<em>bld</em>mountpointbot = 0.01, # This puts struts at top and bottom     strut<em>bld</em>mountpointtop = 0.99, # This puts struts at top and bottom     bshapex = zeros(nbelem+1), #Blade shape, magnitude is irrelevant, scaled based on height and radius above     bshapez = zeros(nbelem+1),     bshapey = zeros(nbelem+1), # but magnitude for this is relevant     angularOffset = 0.0, #Blade shape, magnitude is irrelevant, scaled based on height and radius above     AD15_ccw = false,     verbosity=0, # 0 nothing, 1 basic, 2 lots: amount of printed information     connectBldTips2Twr =true)</p><p>Standard Mesh Matching 5MW, 34m configurations</p><p>#Inputs</p><ul><li><code>Ht::float</code>: height of tower before blades attach (m)</li><li><code>Hb::float</code>: blade height (m)</li><li><code>R::float</code>: bade radius (m)</li><li><code>nblade::int</code>: number of blades</li><li><code>ntelem::int</code>: number of tower elements</li><li><code>nbelem::int</code>: number of blade elements</li><li><code>nselem::int</code>: number of strut elements</li><li><code>strut_twr_mountpointbot::float</code> = 0.01, # factor of blade height where the bottom strut attaches on the tower</li><li><code>strut_twr_mountpointtop::float</code> = 0.99, # factor of blade height where the top strut attaches on the tower</li><li><code>strut_bld_mountpointbot::float</code> = 0.01, # factor of blade height where the bottom strut attaches on the blade</li><li><code>strut_bld_mountpointtop::float</code> = 0.99, # factor of blade height where the top strut attaches on the blade</li><li><code>bshapex::Array{&lt;:float}</code>: Blade shape, magnitude is irrelevant, scaled based on height and radius above</li><li><code>bshapez::Array{&lt;:float}</code>: Blade shape, magnitude is irrelevant, scaled based on height and radius above</li><li><code>bshapey::Array{&lt;:float}</code>: Blade shape, magnitude IS relevant #TODO: resolve this</li><li><code>angularOffset::float</code>: (rad) angular offset of mesh generation, typically used to match CACTUS input.  Value of 0 puts blade 1 at the &quot;north&quot; position and the others populate counterclockwise when looking down</li><li><code>AD15_ccw::boolean</code>: Use AD15 convention of VAWT counter-clockwise with blade root at top (blade points down)</li><li><code>AD15hubR::float</code>: AD15 has a hub radius, so the struts do not go all the way to the center of the axis of rotation, while the structural mesh does.</li></ul><p><strong><code>verbosity::int</code>: 0 nothing, 1 basic, 2 lots: amount of printed information</strong></p><ul><li><code>connectBldTips2Twr::book</code>: True for Darrieus style, false for H-VAWT, but the blade shapes should be appropriate</li></ul><p>#Outputs</p><ul><li><code>mymesh::OWENSFEA.Mesh</code>: see ?OWENSFEA.Mesh</li><li><code>myort::OWENSFEA.Ort</code>: see ?OWENSFEA.Ort</li><li><code>myjoint:Array{&lt;:float}</code>: see ?OWENSFEA.FEAModel.joint</li><li><code>AD15bldNdIdxRng</code>: indices for start and end of all blades for AD15 (includes struts).  Note that strut start nodes may be inside the strut (strut connects to tower, AD15 blade connects to hub wich is a few nodes away from tower)</li><li><code>AD15bldElIdxRng</code>: range of elements for start and end of all AD15 blades (includes struts)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.externalForcing-NTuple{4, Any}" href="#OWENS.externalForcing-NTuple{4, Any}"><code>OWENS.externalForcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">externalForcing(time,timeArray,ForceValHist,ForceDof)</code></pre><p>Internal, linear time interpolation on the input forces (ForceValHist) for each specified ForceDof</p><p>This function specifies external forcing for a transient analysis. Fexternal is a vector of loads and Fdof is a corresponding vector of degrees of freedom the concentrated loads in Fexternal correspond to. The input time allows for arbitrary time varying loads The global degree of freedom number corresponding with the local degree of freedom of a node may be calculated by: globalDOFNumber = (nodeNumber-1)*6 + localDOFnumber The localDOFnumber may range from 1 to 6 such that 1 corresponds to a force in &quot;x direction&quot; of the co-rotating hub frame. 2 and 3 corresponds to a force in the &quot;y&quot; and &quot;z directions&quot; respectively. 4, 5, and 6 correspond to a moment about the &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; directions respectively.</p><p>#Input</p><ul><li><code>time</code>: Current time</li><li><code>timeArray</code>: time associated with ForceValHist</li><li><code>ForceValHist</code>: Forces for each time for each Dof</li><li><code>ForceDof</code>: Dofs within ForceValHist</li></ul><p>#Output</p><ul><li><code>Fexternal</code>: vector of external loads (forces/moments)</li><li><code>Fdof</code>:      vector of corresponding DOF numbers to apply loads to</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.extrap_pred_vals-NTuple{4, Any}" href="#OWENS.extrap_pred_vals-NTuple{4, Any}"><code>OWENS.extrap_pred_vals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extrap_pred_vals(curr_vals, ts, t_out, interp_order)</code></pre><p>Internal, calculates predicted values at t_out based on previous values at earlier times.</p><p><strong>Input</strong></p><ul><li><code>curr_vals::Vector{&lt;:float}</code>: input values</li><li><code>ts::Vector{&lt;:float}</code>: time values corresponding to curr_vals. Left to right, times go from earliest to most recent.</li><li><code>t_out::float</code>: time for values to be extrapolated tocp</li><li><code>interp_order::int</code>: order of the spline fit for the extrapolation, 0 flat, 1 linear, 2 quadratic</li></ul><p><strong>Output</strong></p><ul><li><code>pred_vals</code>: extrapolated values at t_out</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.find_boundary_vals-Tuple{Vector{OWENS.Cycle}}" href="#OWENS.find_boundary_vals-Tuple{Vector{OWENS.Cycle}}"><code>OWENS.find_boundary_vals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the minimum and maximum mean value and maximum range from a vector of cycles</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.find_range-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real" href="#OWENS.find_range-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real"><code>OWENS.find_range</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the range index where the value is found </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.frame_convert-Tuple{Any, Any}" href="#OWENS.frame_convert-Tuple{Any, Any}"><code>OWENS.frame_convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frame_convert(init_frame_vals, trans_mat)</code></pre><p>Internal, transfers 6 DOFs element-wise to a new reference frame</p><p><strong>Input</strong></p><ul><li><code>init_frame_vals::Vector{&lt;:float}</code>: Values in 6 degrees of freedom in the initial reference frame</li><li><code>trans_mat::Array{&lt;:float}</code>: Transformation matrix to the output reference frame</li></ul><p><strong>Output</strong></p><ul><li><code>out_frame_vals</code>: Values in 6 degrees of freedom in the output reference frame</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.generateOutputFilename-Tuple{Any, Any}" href="#OWENS.generateOutputFilename-Tuple{Any, Any}"><code>OWENS.generateOutputFilename</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Internal, generates an output file name depending on the analysis type</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.getGustVel-NTuple{6, Any}" href="#OWENS.getGustVel-NTuple{6, Any}"><code>OWENS.getGustVel</code></a> — <span class="docstring-category">Method</span></header><section><div><ul><li><code>time::TF</code>: in seconds</li><li><code>nominalVinf::TF</code>: Nominal velocity used to calculate the IEC gust size (m/s)</li><li><code>R::TF</code>: Turbine Radius (m)</li><li><code>G_amp::TF</code>: IEC gust amplitude (m/s)</li><li><code>gustT::TF</code>: IEC gust duration (s)</li><li><code>gustDelayT::TF</code>: IEC gust delay time</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.getOWENSPreCompOutput-Tuple{Any}" href="#OWENS.getOWENSPreCompOutput-Tuple{Any}"><code>OWENS.getOWENSPreCompOutput</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getOWENSPreCompOutput(numadIn;yscale=1.0,plyprops = plyproperties())</code></pre><p>Takes numad formatted inputs for composite layup and material properties and runs them through OWENSPreComp</p><p>#Inputs</p><ul><li><code>numadIn::NuMad</code>: see ?NuMad inputs</li><li><code>yscale::float</code>: airfoil thickness scaling</li><li><code>plyprops::plyproperties()</code>: see ?plyproperties for input material properties</li></ul><p>#Outputs</p><ul><li><code>precompoutput::OWENSPreComp.Input</code>: see ?OWENSPreComp.Input</li><li><code>precompinput::OWENSPreComp.properties</code>: see ?OWENSPreComp.properties</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.getRotorPosSpeedAccelAtTime-NTuple{4, Any}" href="#OWENS.getRotorPosSpeedAccelAtTime-NTuple{4, Any}"><code>OWENS.getRotorPosSpeedAccelAtTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getRotorPosSpeedAccelAtTime(t0,time,aziInit)</code></pre><p>Uses the user defined function rotorSpeedProfile() to get the azimuth, speed, and acceleration of the rotor.</p><p>#Input</p><ul><li><code>t0</code>      time at which azimuth integration is beginning</li><li><code>time</code>    current time that position, velocity, and acceleration are being requested</li><li><code>aziInit</code> initial rotor azimuth angle integration will begin at</li></ul><p>#Output</p><ul><li><code>rotorAzimuth</code> azimuth position of rotor (rad) at time</li><li><code>rotorSpeed</code>   rotor speed (Hz) at time</li><li><code>rotorAcceleration</code> rotor acceleration (Hz/s) at time</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.getSectPropsFromOWENSPreComp-Tuple{Any, Any, Any}" href="#OWENS.getSectPropsFromOWENSPreComp-Tuple{Any, Any, Any}"><code>OWENS.getSectPropsFromOWENSPreComp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getSectPropsFromOWENSPreComp(usedUnitSpan,numadIn,precompoutput;GX=false,precompinputs=nothing)</code></pre><p>Arranges the precomp output into the sectional properties required by OWENSFEA</p><p>#Inputs</p><ul><li><code>usedUnitSpan::Array{&lt;:float}</code>: Array specifying the relative (0-1) mesh z locations where the sectional properties are actually called for (interpolation)</li><li><code>numadIn::NuMAD</code>: see ?NuMAD</li><li><code>precompoutput::OWENSPreComp.properties</code>: see ?OWENSPreComp.properties</li><li><code>GX::bool</code>: optional specifies if GX outputs should be output</li><li><code>precompinputs</code>: optional</li></ul><p>#Outputs</p><ul><li><code>sectionPropsArray::SectionPropsArray</code>: see ?OWENSFEA.SectionPropsArray, if !GX bool</li><li><code>stiff</code>: if GX bool</li><li><code>mass</code>: if GX bool</li></ul><p>stiff, mass</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.mapACDMS-NTuple{5, Any}" href="#OWENS.mapACDMS-NTuple{5, Any}"><code>OWENS.mapACDMS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapACDMS(t,mesh,el)</code></pre><p>map OWENSAero forces to OWENS mesh dofs</p><p><strong>Inputs</strong></p><ul><li><code>t::float</code>: time at which to get the loads (can be called repeatedly at the same time or for large time gaps, will infill run as needed)</li><li><code>mesh::OWENSFEA.Mesh</code>: see ?OWENSFEA.Mesh</li><li><code>mesh::OWENSFEA.El</code>: see ?OWENSFEA.El</li></ul><p><strong>Outputs:</strong></p><ul><li><code>ForceValHist::Array(&lt;:float)</code>: Force or moment (N, N-m) at the time corresponding to the time specified</li><li><code>ForceDof::Array(&lt;:int)</code>: DOF numbers cooresponding to forces (i.e. mesh element 1 has dofs 1-6, 2 has dofs 7-12, etc)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.mapAD15-NTuple{4, Any}" href="#OWENS.mapAD15-NTuple{4, Any}"><code>OWENS.mapAD15</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapAD15(t,mesh)</code></pre><p>map AD15 forces to OWENS mesh dofs</p><p><strong>Inputs</strong></p><ul><li><code>t::float</code>: time at which to get the loads (can be called repeatedly at the same time or for large time gaps, will infill run as needed)</li><li><code>mesh::OWENSFEA.Mesh</code>: see ?OWENSFEA.Mesh</li><li><code>mesh::OWENSFEA.El</code>: see ?OWENSFEA.El</li></ul><p><strong>Outputs:</strong></p><ul><li><code>ForceValHist::Array(&lt;:float)</code>: Force or moment (N, N-m) at the time corresponding to the time specified</li><li><code>ForceDof::Array(&lt;:int)</code>: DOF numbers cooresponding to forces (i.e. mesh element 1 has dofs 1-6, 2 has dofs 7-12, etc)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.mapCactusLoadsFile-NTuple{6, Any}" href="#OWENS.mapCactusLoadsFile-NTuple{6, Any}"><code>OWENS.mapCactusLoadsFile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Internal, takes cactus loads and geometry and OWENS mesh and maps the loads to the blades&#39; FEA dofs</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.my_getABD!" href="#OWENS.my_getABD!"><code>OWENS.my_getABD!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>my_getABD(matid::AbstractArray{&lt;:Integer,1}, nply::AbstractArray{&lt;:Integer,1}, tply::AbstractArray{&lt;:Real,1}, theta::AbstractArray{&lt;:Real,1}, q::AbstractArray{&lt;:AbstractArray{&lt;:Real,2},1}), offset::Real</code></p><p><code>my_getABD(lam::Laminate, q::AbstractArray{&lt;:AbstractArray{&lt;:Real,2},1}), offset::Real</code></p><p>Returns A, B, and D matrices</p><p><strong>Arguments:</strong></p><ul><li><code>matid::AbstractArray{&lt;:Integer,1}</code>: material id of each lamina</li><li><code>nply::AbstractArray{&lt;:Integer,1}</code>: number of plies in each lamina</li><li><code>tply::AbstractArray{&lt;:Real,1}</code>: thickness of a ply (m) in each lamina</li><li><code>theta::AbstractArray{&lt;:Real,1}</code>: orientation (deg) of each lamina</li><li><code>q::AbstractArray{&lt;:AbstractArray{&lt;:Real,2}}</code>: Stiffness matrix of each lamina</li><li><code>offset::Real</code>: Optional, used if neutral axis is not centered on the ply. If used, specify distance from neutral axis to upper surface (m).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.my_getplystrain" href="#OWENS.my_getplystrain"><code>OWENS.my_getplystrain</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>my_getplystrain(nply::AbstractArray{&lt;:Integer,1}, tply::AbstractArray{&lt;:Real,1}, theta::AbstractArray{&lt;:Real,1}, resultantstrain::AbstractArray{&lt;:Real,1}, offset::Real)</code></p><p><code>my_getplystrain(lam::Laminate, resultantstrain::AbstractArray{&lt;:Real,1}, offset::Real)</code></p><p><strong>Optional Argument</strong></p><ul><li><code>offset::Real</code>: Optional, used if neutral axis is not centered on the ply. If used, specify distance from neutral axis to upper surface (m).</li></ul><p>Calculates strains in each ply aligned with principal material direction.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.my_getz" href="#OWENS.my_getz"><code>OWENS.my_getz</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>getz(tply::AbstractArray{&lt;:Real,1}, nply::AbstractArray{&lt;:Integer,1}, offset::Real)</code></p><p><code>getz(lam::Laminate, offset::Real)</code></p><p>Returns a laminate&#39;s z-coordinates (coordinates of top and bottom of laminas) given the thickness of plies in each lamina and the number of plies in each lamina. Offset is optional, defaults to 0.0, is the distance from the neutal axis to the upper ply if the laminate is not centered about the neutral axis of a beam.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.mywrite_vtk-NTuple{5, Any}" href="#OWENS.mywrite_vtk-NTuple{5, Any}"><code>OWENS.mywrite_vtk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mywrite_vtk(name, assembly::Assembly, [state::AssemblyState, ]λ::Number,
    eigenstate::AssemblyState; scaling=1.0, mode_scaling=1.0, cycles=1,
    steps=100)</code></pre><p>Write a series of files corresponding to the elastic motion of the <code>assembly</code> about the deformed state encoded in <code>state</code> defined by the eigenvalue <code>λ</code> and the eigenvector encoded in <code>eigenstate</code> over the time period specified by <code>time</code>.</p><p>The steady-state deflections can be scaled with <code>scaling</code> and the eigenmode deflections can be scaled using <code>mode_scaling</code>.</p><p>The current time is encoded in the metadata tag &quot;time&quot;</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.mywrite_vtk-Tuple{Any, Any}" href="#OWENS.mywrite_vtk-Tuple{Any, Any}"><code>OWENS.mywrite_vtk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mywrite_vtk(name, assembly::Assembly; kwargs...)
mywrite_vtk(name, assembly::Assembly, state::AssemblyState; kwargs...)
mywrite_vtk(name, assembly::Assembly, history::Vector{&lt;:AssemblyState}], dt;
    kwargs...)</code></pre><p>Write the deformed geometry (and associated data) to a VTK file for visualization using ParaView.</p><p>The <code>state</code> argument may be omitted to write the original geometry to a VTK file without any associated data.</p><p>If the solution time <code>history</code> is provided, the time step must also be provided</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sections = nothing</code>: Cross section geometry corresponding to each point,  defined in a frame aligned with the body frame but centered around the  corresponding point. Defined as an array with shape <code>(3, ncross, np)</code> where <code>ncross</code>  is the number of points in each cross section and <code>np</code> is the number of points.</li><li><code>scaling=1.0</code>: Parameter to scale the deflections (only valid if state is provided)</li><li><code>metadata=Dict()</code>: Dictionary of metadata for the file(s)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.omegaSpecCheck-NTuple{4, Any}" href="#OWENS.omegaSpecCheck-NTuple{4, Any}"><code>OWENS.omegaSpecCheck</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Internal, gets specified rotor speed at time</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.owens-Tuple{Any, Any}" href="#OWENS.owens-Tuple{Any, Any}"><code>OWENS.owens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">owens(owensfile,analysisType;
    delta_t=2e-3,
    numTS=100,
    tocp=[0.0,1.1],
    Omegaocp=[0.0,1.0],
    OmegaInit=0.0,
    OmegaGenStart=0.0,
    usingRotorSpeedFunction=false,
    nlOn=true,
    Omega=0.0,
    turbineStartup=0,
    spinUpOn=false,
    numModesToExtract=20,
    displInitGuess=0.0,
    airDensity=1.2041,
    aeroElasticOn = false,
    guessFreq = 0,
    gravityOn = true,
    generatorOn = false,
    omegaControl = false,
    iterationType = &quot;NR&quot;, # nlParams
    adaptiveLoadSteppingFlag = true,
    tolerance = 1.0000e-06,
    maxIterations = 50,
    maxNumLoadSteps = 20,
    minLoadStepDelta = 0.0500,
    minLoadStep = 0.0500,
    prescribedLoadStep = 0.0,
    elementOrder = 1,
    numDofPerNode = 6,
    hydroOn = false,
    platformTurbineConnectionNodeNumber = 1,
    JgearBox =0.0,
    gearRatio = 1.0,
    gearBoxEfficiency = 1.0,
    useGeneratorFunction = false,
    generatorProps = 0.0,
    driveTrainOn = false)</code></pre><p>Original serial and file reading method of running an analysis.</p><p>#Inputs See ?OWENS.Model and ?OWENSFEA.FEAModel</p><p>#Outputs See ?OWENS.Unsteady, ?OWENSFEA.Modal</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.plotMesh-NTuple{7, Any}" href="#OWENS.plotMesh-NTuple{7, Any}"><code>OWENS.plotMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>plotMesh plots a mesh with various orthographic and isometric views plotMesh(mesh,colorstring,meshSeg)</p><p>This function plots a mesh in a 3D with isometric view.</p><p>#Input</p><ul><li><code>mesh</code>:         object containing mesh data</li><li><code>colorstring</code>:  string containing color for plotting</li><li><code>meshSeg</code>:      array containing number of elements per mesh segment</li><li><code>ax1</code>: handle to the 1 plot</li><li><code>ax2</code>: handle to the 2 plot</li><li><code>ax3</code>: handle to the 3 plot</li><li><code>ax4</code>: handle to the 4 plot</li></ul><p>#Output NONE</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.rainflow-Tuple{Any}" href="#OWENS.rainflow-Tuple{Any}"><code>OWENS.rainflow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rainflow(signal;nbins_range=10,nbins_mean=10)</code></pre><p>Convenience function that returns the binned cycles with the corresponding ranges and means</p><p><strong>Inputs</strong></p><ul><li><code>signal::Array{&lt;:Real,1}</code>: data input</li><li><code>nbins_range::Array{&lt;:Int,1}</code>: Number of bins for range</li><li><code>nbins_mean::Array{&lt;:Int,1}</code>: Number of bins for mean</li><li><code>m</code>` :    Wohler exponent (default is 3)</li><li><code>Teq</code>` : The equivalent number of load cycles (default is 1, but normally the time duration in seconds is used)</li></ul><p><strong>Outputs:</strong></p><ul><li><code>Ncycles::Array{&lt;:Real,2}</code>: Summed/binned cycles with columns corresponding to mean levels and rows corresponding to range levels</li><li><code>meanIntervals::Array{&lt;:Real,1}</code>: Mean levels corresponging with bins columns</li><li><code>rangeIntervals::Array{&lt;:Real,1}</code>: Range levels corresponging with bins rows</li><li><code>equivalentLoad::Array{&lt;:Real,1}</code>: Design equivalent load for each mean level</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.readBCdata-Tuple{Any, Any, Any}" href="#OWENS.readBCdata-Tuple{Any, Any, Any}"><code>OWENS.readBCdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readBCdata(bcfilename,numNodes,numDofPerNode)</code></pre><p>This function reads the boundray condition file and stores data in the boundary condition object.</p><p>#Input</p><ul><li><code>bcfilename::string</code>:    string containing boundary condition filename</li><li><code>numNodes::int</code>:      number of nodes in structural model</li><li><code>numDofPerNode::int</code>: number of degrees of freedom per node</li></ul><p>#Output</p><ul><li><code>BC::OWENSFEA.BC_struct</code>:   see OWENSFEA.BC_struct, object containing boundary condition data</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.readBladeData-Tuple{Any}" href="#OWENS.readBladeData-Tuple{Any}"><code>OWENS.readBladeData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readBladeData(filename)</code></pre><p>This function reads blade data from file</p><p>#Input</p><ul><li><code>filename::string</code>:   string containing /path/to/bladedata.bld</li></ul><p>#Output</p><ul><li><code>bladeData::BladeData</code>:  see ?BladeData object containing blade data</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.readCactusGeom-Tuple{Any}" href="#OWENS.readCactusGeom-Tuple{Any}"><code>OWENS.readCactusGeom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Internal, reads cactus .geom file and stores each column in an array within the CactusGeom struct</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.readElementData-NTuple{4, Any}" href="#OWENS.readElementData-NTuple{4, Any}"><code>OWENS.readElementData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readElementData(numElements,elfile,ortfile,bldfile</code></pre><p>Reads element data and stores data in the element data object.</p><p>#Input</p><ul><li><code>numElements::int</code>:  number of elements in structural mesh</li><li><code>elfile::string</code>:       element data path/to/filename</li><li><code>ortfile::string</code>:      element orientation path/to/filename</li><li><code>bldfile::string</code>:      blade data path/to/filename</li></ul><p>#Output</p><ul><li><code>el::OWENSFEA.El</code>:       see OWENSFEA.El    element data object</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.readGeneratorProps-Tuple{Any}" href="#OWENS.readGeneratorProps-Tuple{Any}"><code>OWENS.readGeneratorProps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readGeneratorProps(generatorfilename)</code></pre><p>This function reads generator properties from file.</p><p>#Input</p><ul><li><code>generatorfilenanme::string</code>:  = string containing path/to/generatorfile</li></ul><p>#Output</p><ul><li><code>genprops</code>:    = model object containing generator properties</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.readMesh-Tuple{Any}" href="#OWENS.readMesh-Tuple{Any}"><code>OWENS.readMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readMesh(filename)</code></pre><p>Reads the mesh file and stores data in the mesh object.</p><p>input:</p><ul><li><code>filename::string</code> string containing mesh path/to/filename.mesh</li></ul><p>output:</p><ul><li><code>mesh::OWENSFEA.Mesh</code> see OWENSFEA.Mesh</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.readNuMadGeomCSV-Tuple{Any}" href="#OWENS.readNuMadGeomCSV-Tuple{Any}"><code>OWENS.readNuMadGeomCSV</code></a> — <span class="docstring-category">Method</span></header><section><div><p>readNuMadGeomCSV(NuMad<em>geom</em>xlscsv_file)</p><p>Parameters defining the rotor (apply to all sections).</p><p><strong>Arguments</strong></p><ul><li><code>NuMad_geom_xlscsv_file::String</code>: name of the numad excel CSV file being read (!!! THE NUMAD TAB MUST BE SAVED AS A CSV FOR THIS TO WORK !!!)</li></ul><p><strong>Returns</strong></p><ul><li><code>Output::NuMad</code>: numad structure as defined in the NuMad structure docstrings.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.readNuMadMaterialsCSV-Tuple{Any}" href="#OWENS.readNuMadMaterialsCSV-Tuple{Any}"><code>OWENS.readNuMadMaterialsCSV</code></a> — <span class="docstring-category">Method</span></header><section><div><p>readNuMadMaterialsCSV(NuMad<em>materials</em>xlscsv_file)</p><p>Parameters defining the rotor materials.</p><p><strong>Arguments</strong></p><ul><li><code>NuMad_materials_xlscsv_file::String</code>: name of the numad excel CSV file being read (!!! THE NUMAD TAB MUST BE SAVED AS A CSV FOR THIS TO WORK !!!)</li></ul><p><strong>Returns</strong></p><ul><li><code>Output::plyproperties</code>: plyproperties structure as defined in the plyproperties structure docstrings.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.readResultsModalOut-Tuple{Any, Any}" href="#OWENS.readResultsModalOut-Tuple{Any, Any}"><code>OWENS.readResultsModalOut</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Internal, reads modal file and returns freq, damp, and modeshapes</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.rigidBodyRotation-NTuple{5, Any}" href="#OWENS.rigidBodyRotation-NTuple{5, Any}"><code>OWENS.rigidBodyRotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rigidBodyRotation(B1,B2,B3,AngleArray,AxisArray)</code></pre><p>Performs a coordinate transformation from a local body &quot;B&quot;(element) frame to a common hub frame &quot;H&quot; via a 3-2-3 euler rotation sequence</p><p>#Input</p><ul><li><code>B1</code>:         array containing body frame 1 coordinates of points to be mapped to the hub frame</li><li><code>B2</code>:         array containing body frame 2 coordinates of points to be mapped to the hub frame</li><li><code>B3</code>:         array containing body frame 3 coordinates of points to be mapped to the hub frame</li><li><code>AngleArray</code>:  Array of angles for Euler rotation sequence</li><li><code>AxisArray</code>:   Array of axes for Euler rotation sequence</li></ul><p>#Output</p><ul><li><code>H1</code>:         array containg hub frame 1 coordinates of points mapped to the hub frame from body frame</li><li><code>H2</code>:         array containg hub frame 2 coordinates of points mapped to the hub frame from body frame</li><li><code>H3</code>:         array containg hub frame 3 coordinates of points mapped to the hub frame from body frame</li></ul><p>That is CHtoB = [M3(SweepAngle)][M2(Theta)][M3(Psi)];</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.run34m-NTuple{6, Any}" href="#OWENS.run34m-NTuple{6, Any}"><code>OWENS.run34m</code></a> — <span class="docstring-category">Method</span></header><section><div><p>run34m(inputs,feamodel,mymesh,myel,aeroForces,deformAero;steady=true,system=nothing,assembly=nothing,VTKFilename=&quot;./outvtk&quot;)</p><p>helper function that rearranges the outputs into the expected 34m output     # Input     * <code>inputs::Model</code>: see ?Model     * <code>topModel::FEAModel</code>: see ?OWENSFEA.FEAModel     * <code>mesh::Mesh</code>: see ?OWENSFEA.Mesh     * <code>el::El</code>: see ?OWENSFEA.El     * <code>aeroForces::function</code>: Fexternal, Fdof = aero(t) where Fexternal is the force on each affected mesh dof and Fdof is the corresponding DOFs affected     * <code>deformAero::function</code>: see deformTurb(azi;newOmega=-1,newVinf=-1,bld<em>x=-1,bld</em>z=-1,bld_twist=-1,steady=false)     * <code>steady::bool</code>: run steadystate with no aero or not     * <code>system</code>: see ?GXBeam.System     * <code>assembly</code>: see ?GXBeam.Assembly     * <code>VTKFilename::string</code>: Unused: path and name of VTK output</p><pre><code class="nohighlight hljs"># Output
* `eps_x`: strain history for eps_xx_0 for (Nbld,N_ts,mymesh.meshSeg[2]+1)
* `eps_y`: strain history for eps_xx_z like above
* `eps_z`: strain history for eps_xx_y like above
* `kappa_x`: strain history for gam_xz_0 like above
* `kappa_y`: strain history for gam_xz_y like above
* `kappa_z`: strain history for gam_xy_0 like above
* `t`: time array
* `FReactionHist`: Nodal reaction 6dof forces history
* `OmegaHist`: rotational speed array history
* `genTorque`: generator torque history
* `torqueDriveShaft`: driveshaft torque history
* `aziHist`: azimuthal history array
* `uHist`: mesh displacement history for each dof
* `epsilon_x_hist`: strain history for eps_xx_0 for each dof
* `epsilon_y_hist`: strain history for eps_xx_z for each dof
* `epsilon_z_hist`: strain history for eps_xx_y for each dof
* `kappa_x_hist`: strain history for gam_xz_0 for each dof
* `kappa_y_hist`: strain history for gam_xz_y for each dof
* `kappa_z_hist`: strain history for gam_xy_0 for each dof</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.runDLC-Tuple{Any, Any, Any}" href="#OWENS.runDLC-Tuple{Any, Any, Any}"><code>OWENS.runDLC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>runDLC(DLCs,Inp,path;     Vinf<em>range=LinRange(5,20,16),     IEC</em>std=&quot;&quot;2&quot;&quot;,     WindChar=&quot;&quot;A&quot;&quot;,     WindClass=1,     turbsimpath=&quot;./turbsimfiles&quot;,     templatefile=&quot;./templateTurbSim.inp&quot;,     pathtoturbsim=&quot;../../openfast/build/modules/turbsim/turbsim&quot;,     NumGrid<em>Z=100,     NumGrid</em>Y=100,     Vref=10.0,     Vdesign=11.0,     grid_oversize=1.1,     regenWindFiles=false)</p><pre><code class="nohighlight hljs"># Input
* `DLCs`: [&quot;1_1&quot;,&quot;1_2&quot;]
* `Inp::MasterInput`: see ?OWENS.MasterInput
* `path`: desired path to run everything
* `Vinf_range`: =LinRange(5,20,16),
* `IEC_std`: =&quot;&quot;2&quot;&quot;,
* `WindChar`: =&quot;&quot;A&quot;&quot;,
* `WindClass`: =1,
* `turbsimpath`: =&quot;./turbsimfiles&quot;, path where it dumps the turbsim files
* `templatefile`: =&quot;./template_files/templateTurbSim.inp&quot;,
* `pathtoturbsim`: =&quot;../../openfast/build/modules/turbsim/turbsim&quot;,
* `NumGrid_Z`: =100,
* `NumGrid_Y`: =100,
* `Vref`: =10.0,
* `Vdesign`: =11.0, # Design or rated speed
* `grid_oversize`: =1.1,
* `regenWindFiles`: =false

# Output
* `nothing`:</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.simpleGenerator-Tuple{Any, Any}" href="#OWENS.simpleGenerator-Tuple{Any, Any}"><code>OWENS.simpleGenerator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simpleGenerator(generatorProps,genSpeed)</code></pre><p>Caclulates generator torque for simple induction generator</p><p>#Input</p><ul><li><code>generatorProps</code> object containing generator properties, see ?model</li><li><code>genSpeed::float</code>       generator speed (Hz)</li></ul><p>#Output</p><ul><li><code>genTorque::float</code>      generator torque</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.sort_peaks" href="#OWENS.sort_peaks"><code>OWENS.sort_peaks</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function sorts out points where the slope changes sign</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.sum_cycles-Union{Tuple{T}, Tuple{Vector{OWENS.Cycle}, Union{StepRangeLen{T}, Vector{T}}, Union{StepRangeLen{T}, Vector{T}}}} where T&lt;:Real" href="#OWENS.sum_cycles-Union{Tuple{T}, Tuple{Vector{OWENS.Cycle}, Union{StepRangeLen{T}, Vector{T}}, Union{StepRangeLen{T}, Vector{T}}}} where T&lt;:Real"><code>OWENS.sum_cycles</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sums the cycle count given intervals of range<em>intervals and mean</em>intervals. The range<em>intervals and mean</em>intervals are given in fraction of range size</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.timeIntegrateSubSystem-NTuple{8, Any}" href="#OWENS.timeIntegrateSubSystem-NTuple{8, Any}"><code>OWENS.timeIntegrateSubSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timeIntegrateSubSystem(M,K,C,F,delta_t,u,udot,uddot)</code></pre><p>Internal, performs integration of a system using the Newmark-Beta method (constant-average acceleration sceheme).</p><p>#Input</p><ul><li><code>M</code>:       system mass matrix</li><li><code>K</code>:       system sttiffness matrix</li><li><code>C</code>:       system damping matrix</li><li><code>F</code>:       system force vector</li><li><code>delta_t</code>: time step</li><li><code>u</code>:       displacement at beginning of time step</li><li><code>udot</code>:    velocity at beginning of time step</li><li><code>uddot</code>:   acceleration at beginning of time step</li></ul><p>#Output</p><ul><li><code>unp1</code>:       displacement at end of time step</li><li><code>udotnp1</code>:    velocity at end of time step</li><li><code>uddotnp1</code>:   acceleration at end of time step</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.transMat-Tuple{Any, Any, Any}" href="#OWENS.transMat-Tuple{Any, Any, Any}"><code>OWENS.transMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transMat(theta1, theta2, theta3)</code></pre><p>Internal, computes the 3x3 transformation matrix for given input rotations. The generated matrix is the closest orthonormal matrix to the Bernoulli-Euler transformation matrix from beam theory, which assumes small rotations. A full description of this matrix is found in the &quot;FASTCoordinateSystems.doc&quot; document by Jason Jonkman.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.trapezoidalRule-NTuple{4, Any}" href="#OWENS.trapezoidalRule-NTuple{4, Any}"><code>OWENS.trapezoidalRule</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Internal, simple trapezoidal rule integration</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.updateRotorRotation-NTuple{9, Any}" href="#OWENS.updateRotorRotation-NTuple{9, Any}"><code>OWENS.updateRotorRotation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>updateRotorRotation updates rotor rotation</p><pre><code class="nohighlight hljs">updateRotorRotation(Irotor,Crotor,Krotor,shaftTorque,genTorque,azi_s,Omega_s,OmegaDot_s,delta_t)</code></pre><p>Internal, updates the rotor rotation given rotor properties and external torques</p><p>#Input</p><ul><li><code>Irotor</code>:      rotor inertia</li><li><code>Crotor</code>:      arbitrary rotor damping</li><li><code>Krotor</code>:      arbitrary rotor stiffness</li><li><code>shaftTorque</code>: torque from external forces on rotor</li><li><code>genTorque</code>:   torque from generator</li><li><code>azi_s</code>:       rotor azimuth (rad) at beginning of time step</li><li><code>Omega_s</code>:     rotor speed (Hz) at beginning of time step</li><li><code>OmegaDot_s</code>:  rotor acceleration (Hz/s) at beginning of time step</li><li><code>delta_t</code>:     time step</li></ul><p>#Output</p><ul><li><code>azi_sp1</code>:       rotor azimuth (rad) at end of time step</li><li><code>Omega_sp1</code>:     rotor speed (Hz/s) at end of time step</li><li><code>OmegaDot_sp1</code>:  rotor acceleration (Hz/s) at end of time step</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.userDefinedRotorSpeedProfile-Tuple{Any}" href="#OWENS.userDefinedRotorSpeedProfile-Tuple{Any}"><code>OWENS.userDefinedRotorSpeedProfile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Internal, unused, userDefinedRotorSpeedProfile</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.viz-Tuple{Any}" href="#OWENS.viz-Tuple{Any}"><code>OWENS.viz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">viz(;mesh=[],meshFile=&quot;none&quot;,resultsFile=&quot;none&quot;,selectedMode=10,sf=10)</code></pre><p>Plots the mode shapes of a mode from a modal analysis performed using the OWENS toolkit.  Either send the mesh struct or the mesh filename but not both</p><p>#Input</p><ul><li><code>mesh::OWENSFEA.Mesh</code>:    Mesh struct, See ?OWENSFEA.Mesh</li><li><code>meshFile::String</code>:       optional string containing mesh file name</li><li><code>resultsFile::String</code>:    optional string containing results file name</li><li><code>selectedMode::Int</code>:      integer denoting selected mode to plot</li><li><code>sf::Float</code>:                scale factor for mode shape displacements</li></ul><p>#Output None</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OWENS.writeOwensNDL-NTuple{4, Any}" href="#OWENS.writeOwensNDL-NTuple{4, Any}"><code>OWENS.writeOwensNDL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">writeOwensNDL(fileRoot, nodes, cmkType, cmkValues)</code></pre><p>writes a nodal input file</p><p>#Intput</p><ul><li><code>fileRoot::string</code>: string path to desired location with name but no extension</li><li><code>nodes::int</code>: node numbers for C/M/K</li><li><code>cmkType::string</code>: &quot;C&quot; &quot;M&quot; or &quot;K&quot;</li><li><code>cmkValues::float</code>: C/M/K value</li></ul><p>#Output</p><ul><li><code>none</code>:</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../FramesOfReference/">« Frames of Reference</a><a class="docs-footer-nextpage" href="../../legacyUserGuide/">Legacy User Guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 14 June 2024 23:40">Friday 14 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
